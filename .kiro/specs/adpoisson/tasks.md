# 実装計画

## 凡例
- (P): Phase内で並列実行可能

## Phase 1: 基盤構築とデータ構造
- [x] 1. プロジェクト構造のセットアップ
  - `src/ADPoisson.jl`, `src/types.jl`, `src/core.jl` 等の空ファイル作成
  - `ADburgers` を参考にエントリポイントを記述
- [x] 1a. Project.toml の作成
  - name = "ADPoisson"
  - deps: Plots, Printf, Statistics, Test, LinearAlgebra
- [x] 2. データ構造の実装 (`src/types.jl`)
  - `ProblemSpec` の定義 (Lx, Ly, Lz, alpha, source, dirichlet)
  - `BoundaryConditions` の定義 (g_xlo, g_xhi, g_ylo, g_yhi, g_zlo, g_zhi)
  - `TaylorBuffers3D` の定義 (bufA, bufB, acc)
  - `TaylorArrays3D` の定義（検証用途のみ、任意）
  - AD対応の型パラメトリック化（`T<:Real`）を適用
  - `SolverConfig` の定義 (グリッド数, M, dt, max_steps, epsilon)
  - `Solution` の定義 (物理座標, u配列)
  - _Requirements: コア機能-ソルバー, 計算格子_
  - _Design: BoundaryConditions, TaylorBuffers3D, TaylorArrays3D_

## Phase 2: コアアルゴリズム実装
> Phase 1 完了後に開始
- [x] 3. グリッド生成と初期化 (`src/core.jl`, `src/problems.jl`)
  - `make_grid(config)` 実装（内点のみ）
  - `initialize_solution(config, prob)` 実装
  - 物理座標配列 $x, y, z$ の計算
  - 初期条件 $u=0$ の設定
  - _Requirements: 計算格子, 初期条件_
- [x] 4. 解析解とソース項の実装 (`src/problems.jl`)
  - `exact_solution(x, y, z, alpha)` 実装
  - `source_term(x, y, z)` 実装 ($f=0$ だが)
  - `dirichlet_bc(x, y, z, alpha)` 実装
  - `boundary_from_prob(prob)` 実装（Dirichlet関数を6面に分解）
  - _Requirements: 解析解_
- [x] 5a. Laplacian 演算子の実装 (`src/core.jl`) (P)
  - `laplacian!(Lu, u, config)`
  - 7点差分の実装
  - _Requirements: Taylor級数漸化式_
- [x] 5b. Taylor係数計算ルーチンの実装 (`src/core.jl`) (P)
  - `taylor_step!(next, curr, f, m, config)`
  - `accumulate_taylor!(acc, coeff, dt_pow)`
  - `horner_update!` 実装（検証用途のみ）
  - 漸化式の実装
  - depends: [5a]
  - _Requirements: 時間積分手法, Taylor級数漸化式_
- [x] 5c. Ping-pong バッファリングの実装 (`src/core.jl`) (P)
  - `TaylorBuffers3D` を用いた逐次係数生成
  - depends: [5a, 5b]
  - _Requirements: メモリ効率_
- [x] 6. 境界条件の実装（現行実装, legacy） (`src/boundary.jl`) (P)
  - `apply_bc!(u, bc, m, config)`
  - Dirichlet条件 (ghost 1層更新) の実装
  - ghost更新は面のみ（エッジ・コーナーは更新しない）
  - 高次境界（任意, `order=:high`）は `m=0` のみ 3次外挿
  - **注意**: ghost 2層 + 4次境界への移行は Task 25 で実施する
  - _Requirements: （legacy実装 - 新仕様 ghost 2層 は Task 25 で対応）_
- [x] 7. factory.jl の実装 (`src/factory.jl`)
  - `make_problem(config, alpha)` 等のヘルパーを実装
  - `boundary_from_prob(prob)` を利用して `BoundaryConditions` を生成
  - _Design: factory.jl_

## Phase 3: ソルバー統合と検証
- [x] 8. メインループの実装 (`src/core.jl`)
  - `solve(config, prob)` 実装
  - 時間ステップループ、収束判定 ($r=Lu-f$ 相対残差)
  - `compute_residual!` 実装（内点のみ）
  - 相対残差 $\|r\|_2 / \max(\|r_0\|_2, 1)$ を採用
  - 擬似時間ステップ履歴を `run_YYYYMMDD_HHMMSS/` 配下に保存（`history_nx{nx}_ny{ny}_nz{nz}_M{M}_steps{steps}.txt`）
  - 拡散数 $Fo$ の推奨条件チェック（警告）
  - depends: [5a, 5b, 5c, 6]
  - _Requirements: ソルバー, 時間積分手法_
- [x] 9. 可視化機能の実装 (`src/visualization.jl`)
  - `plot_slice(sol, ...)` 実装 (XZ面)
  - 解析解との差分（|u-u_exact|）の可視化
  - `results/` ディレクトリを作成して保存
  - 保存の命名規則: `exact_nx{nx}_ny{ny}_nz{nz}.png`, `error_nx{nx}_ny{ny}_nz{nz}_M{M}_steps{steps}.png`
  - depends: [8]
  - _Requirements: Julia実装-可視化_
- [x] 10. CLIと実行スクリプト (`scripts/main.jl`)
  - コマンドライン引数処理
  - `--nx --ny --nz --M --dt --Fo --max-steps --epsilon --alpha --bc-order --lap-order --output-dir` に対応
  - `factory.jl` を利用して問題生成
  - depends: [7, 8]
  - _Requirements: Julia実装-パラメータ_
- [x] 11. 検証とテスト (`test/runtests.jl`)
  - $N=16, 32, 64$ でのL2誤差収束確認
  - 相対 $L2$ 誤差 $\|u-u_{\text{exact}}\|_2/\|u_{\text{exact}}\|_2 \le 10^{-3}$ を満たすこと
  - `test/core.jl`, `test/problems.jl` の構成で分割
  - `@testset "laplacian!"`, `@testset "taylor_step!"`, `@testset "convergence_order"` を追加
  - `laplacian!` テスト: 一様場 $u=c$ で $L=0$ を確認
  - `taylor_step!` テスト: $m=0$ で $(u)_1 = Lu - f$ を確認
  - 最大誤差も計算して出力（合否判定には使わない）
  - depends: [8]
  - 単体テスト（laplacian!, taylor_step!）は Phase 2 完了時点で実行可能
  - _Requirements: 検証機能_

## Phase 4: 線形ソルバー（SOR/SSOR/CG）
> Phase 3 完了後に開始
- [x] 12. SOR ソルバーの実装 (`src/sor.jl`)（内点のみ、Dirichlet境界の寄与は RHS に取り込み）
  - RB-SOR 反復
  - 相対残差 $\|r\|_2/\max(\|r_0\|_2,1)$ による収束判定
  - 収束履歴の出力（`step`, `err_l2`, `res_l2`）
  - 反復ループ内は `if` 分岐なし
  - depends: [5a, 6]
  - _Requirements: 線形ソルバー_
  - _Design: 線形ソルバー（SOR）_
- [x] 12b. SSOR ソルバーの実装 (`src/sor.jl`)
  - RBSSOR（4スイープ対称）による反復
  - 収束履歴の出力（`step`, `err_l2`, `res_l2`）
  - SOR と同一ファイル（`src/sor.jl`）に実装する
  - depends: [5a, 6, 12]
  - _Requirements: 線形ソルバー_
  - _Design: 線形ソルバー（SSOR）_
- [x] 13. CG ソルバーの実装 (`src/cg.jl`)（前処理: `:none` / `:ssor`）
  - 明示行列を組まず `laplacian!` による行列作用
  - SSOR 前処理（RBSSOR 4 スイープ、対称）
  - 相対残差の収束判定と履歴出力
  - 反復ループ内は `if` 分岐なし
  - depends: [5a, 6, 12, 12b]
  - _Requirements: 線形ソルバー_
  - _Design: 線形ソルバー（CG/SSOR）_
- [x] 14. 収束性の比較
  - 擬似時間法（Taylor）と SOR/CG の収束履歴を同一指標で比較
  - 例題は共通の検証問題を使用
  - 比較結果を `run_YYYYMMDD_HHMMSS/` に保存
  - depends: [8, 12, 13]
  - _Requirements: 検証機能_
  - _Design: 比較スクリプト_
- [x] 15. Phase 4 テスト (`test/solvers.jl`)
  - SOR: 小規模問題で既知解との一致を確認
  - CG: SORと同一問題で収束を確認
  - depends: [12, 13]
  - _Requirements: 線形ソルバー_
  - _Design: テスト戦略_

## Phase 5: マルチグリッド的加速（検討）
> Phase 3 完了後に開始
- [ ] 16. レベル1（疑似MG）の実装 (`src/mg.jl`)（不採用）
  - 残差 $r=Lu-f$ を用いた補正ステップを実装
  - 補正ステップも Fo クリップを適用
  - 実験済みで不採用のため実装対象外
  - depends: [5a, 6, 8]
  - _Requirements: 加速（マルチグリッド的アプローチ）_
  - _Design: マルチグリッド的加速_
- [ ] 17. レベル2（2-level MG）の実装 (`src/mg.jl`)（不採用）
  - coarse grid の生成（$N/2$）と $R/P$ の実装
  - coarse 境界値は boundary function から直接評価
  - 実験済みで不採用のため実装対象外
  - depends: [16]
  - _Requirements: 加速（マルチグリッド的アプローチ）_
  - _Design: マルチグリッド的加速_
- [x] 18. レベル3（V-cycle MG）の実装 (`src/mg.jl`)
  - 再帰 V-cycle（最粗格子で直接解法）
  - 誤差方程式 $Le=-r$ を解く場合は coarse でゼロ Dirichlet 境界を適用
  - レベル依存で $\Delta t$ / $M$ を変更可能
  - depends: [5a, 6, 8]
  - _Requirements: 加速（マルチグリッド的アプローチ）_
  - _Design: マルチグリッド的加速_
- [x] 19. 階層 Taylor パラメータ指定の追加
  - CLI に `--mg-level-Ms`, `--mg-level-dt-scales` を追加
  - 配列長がレベル数未満の場合は最後の値を繰り返す
  - `run_config.toml` に設定値を保存
  - テスト: CLI で指定した配列が `run_config.toml` に保存されることを確認
  - depends: [18]
  - _Requirements: 階層 Taylor（Level-dependent Taylor）_
  - _Design: 階層 Taylor（Level-dependent Taylor）_
- [ ] 20. Phase 5 テスト (`test/mg.jl`)（不採用）
  - レベル1: 補正後に残差が減少することを確認
  - レベル2: 2-level MG で収束を確認
  - 実験済みで不採用のため実施対象外
  - depends: [18, 19]
  - _Requirements: 加速（マルチグリッド的アプローチ）_
  - _Design: テスト戦略_
- [x] 21. Correction-Taylor モード追加 (`src/mg.jl`)
  - `vcycle!` に `correction_mode=:classic/:correction-taylor` を追加
  - `correction-taylor` 時は coarse で $L e = -r$（$r=Lu-f$）を Taylor 擬似時間積分で解く
  - coarse へは $-r$（$f-Lu$）を制限した右辺を用いる
  - coarse 補正ではゼロ Dirichlet 境界を適用
  - depends: [18]
  - _Requirements: 補正方程式の Taylor 化（Correction-Taylor）_
  - _Design: 補正方程式の Taylor 化（Correction-Taylor）_
- [x] 22. CLI/設定追加 (`scripts/main.jl`)
  - `--solver mg-correction-taylor` と `--mg-corr-M`, `--mg-corr-dt-scale`, `--mg-corr-steps` を追加
  - **補正方程式（e）側**の pre/post 個別指定として `--mg-corr-nu1`, `--mg-corr-nu2` を追加
  - `run_config.toml` へ `mg_correction`, `mg_corr_M`, `mg_corr_dt_scale`, `mg_corr_steps`,
    `mg_corr_nu1`, `mg_corr_nu2` を保存
  - depends: [21]
  - _Requirements: 補正方程式の Taylor 化（Correction-Taylor）_
  - _Design: 補正方程式の Taylor 化（Correction-Taylor）_
- [x] 23. Correction-Taylor テスト (`test/mg.jl`)
  - `classic` 比較で coarse 補正後に残差低減することを確認
  - 境界条件（ゼロ Dirichlet）適用時に NaN/発散しないことを確認
  - depends: [21, 22]
  - _Requirements: 補正方程式の Taylor 化（Correction-Taylor）_
  - _Design: テスト戦略_
- [x] 24. MGワークスペース導入（バッファ再利用） (`src/mg.jl`)
  - V-cycle 内の `zeros/similar` を排除し、レベルごとに `r/rhs/e/tmp/taylor` を事前確保
  - 再利用時は **配列全域（境界/ゴースト領域を含む）を `fill!`** で初期化する
  - `MGLevelWorkspace` / `MGWorkspace` を定義し `vcycle!` に渡す
  - coarse RHS は `levels[level+1].rhs` を再利用し、補間結果は `levels[level].e` に保持
  - `correction_taylor_solve!` はワークバッファ引数を受け取り再確保しない
  - `classic` の最粗格子は `A` と factorization をキャッシュして再利用
  - depends: [18]
  - _Requirements: MGバッファ再利用_
  - _Design: MGワークスペース（バッファ再利用）_

## Phase 6: ghost 2層仕様への移行
> 仕様更新（ghost 2層, 高次境界4次）を現実装へ反映するフェーズ
- [x] 25. 境界条件の ghost 2層化 (`src/boundary.jl`)
  - `order=:spec` で ghost1/ghost2 の 2次式（`2g-u_adj1`, `2g-u_adj2`）を実装
  - `order=:high` で ghost 2層の 4次式を実装（x/y/z 全面）
  - 係数配列は `m=0` に境界値、`m>=1` は同次式を適用
  - `nx,ny,nz>=4` 未満は `order=:spec` にフォールバック
  - depends: [6]
  - _Requirements: Taylor級数漸化式（ghost 2層境界式）_
  - _Design: Ghost Cell更新 (`boundary.jl`)_
- [ ] 26. コア配列・インデクスの ghost 2層対応 (`src/core.jl`, `src/mg.jl`, `src/cg.jl`)
  - 配列サイズを `(nx+4, ny+4, nz+4)` に更新
  - 内点ループを `3:n+2` へ更新（残差, Taylor 係数, 補間/制限を含む）
  - ghost を含む添字規約の整合を全ソルバーで確認
  - `--lap-order fourth` の実行時エラー guard を解除し、ghost 2層配列で実行可能にする
  - depends: [25]
  - _Requirements: 計算格子, Taylor級数漸化式_
  - _Design: データモデル, コアアルゴリズム_
- [ ] 27. ghost 2層向けテスト更新 (`test/core.jl`, `test/mg.jl`)
  - 境界適用テストを ghost 2層式に更新
  - `order=:high` の `m=0`/`m>=1` の両方を検証
  - 既存収束テストが新添字規約で通ることを確認
  - `--lap-order fourth` の統合テスト（CLI経由）を追加
  - depends: [25, 26]
  - _Requirements: 検証機能_
  - _Design: テスト戦略_

## Phase 7: 4次ラプラシアン（暫定）
- [x] 28. 4次ラプラシアン核と `--lap-order` 配線（暫定） (`src/core.jl`, `scripts/main.jl`, `test/core.jl`)
  - `laplacian!` に `order=:second|:fourth` を追加し、`laplacian4!`（半径2）を実装
  - `--lap-order second|fourth` を CLI に追加し、`run_config.toml` へ `lap_order` を保存
  - `taylor_step!` / 残差計算に `lap_order` を配線
  - 4次ラプラシアン単体テスト（収束次数）を追加
  - 現行（ghost 1層）では `--lap-order fourth` を実行時エラーとしてガード
  - depends: [5a, 10, 11]
  - _Requirements: 三次元ポアソン方程式ソルバー, Julia実装-パラメータ_
  - _Design: 関数シグネチャ, CLI引数（scripts/main.jl）_
